# Haskell ä¸­çš„åº”ç”¨å‡½å­

> åŸæ–‡ï¼š<https://dev.to/__namc/applicative-functors-inhaskell-gm>

### å‡½å­

æ ¹æ® [Haskell](https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Functor.html) çš„è¯´æ³•ï¼Œå‡½å­å°±æ˜¯å¯ä»¥è¢«æ˜ å°„çš„ä¸œè¥¿ã€‚æ¢å¥è¯è¯´ï¼Œå®ƒæ˜¯å¯¹ä¸Šä¸‹æ–‡çš„æŠ½è±¡ï¼Œèƒ½å¤Ÿå°†ä¸€ä¸ªå‡½æ•°åº”ç”¨äºä¸Šä¸‹æ–‡ä¸­çš„æ‰€æœ‰äº‹ç‰©ã€‚
ä¸Šä¸‹æ–‡å¯ä»¥å®šä¹‰ä¸ºå®¹å™¨ã€è®¡ç®—ç­‰ã€‚
å¦‚:åˆ—è¡¨æˆ–åºåˆ—æ˜¯åŒè´¨å…ƒç´ çš„å®¹å™¨ã€‚æ‚¨å¯ä»¥å¯¹æ¯ä¸ªå…ƒç´ åº”ç”¨ä¸€ä¸ªå‡½æ•°ï¼Œè¿™ä¼šäº§ç”Ÿä¸€ä¸ªç”±è¯¥å‡½æ•°è½¬æ¢çš„æ–°çš„å…ƒç´ åºåˆ—ã€‚

è®©æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªæ–°çš„ä»¿å‡½æ•°ï¼Œå®ç°`myfmap`ï¼Œè¿™æ ·`Data.Map`å°±æ˜¯æ–°ä»¿å‡½æ•° typeclass çš„ä¸€ä¸ªå®ä¾‹ã€‚`myfmap`å°†å‡½æ•°`f`åº”ç”¨äºä»¿å‡½æ•°ä¸Šä¸‹æ–‡ä¸­çš„å€¼ï¼ŒåŒæ—¶ä¿ç•™ä¸Šä¸‹æ–‡ã€‚

```
import Data.Map as DataMap
import Data.List as DataList

class MyFunctor f where
  myfmap :: (a -> b) -> f a -> f b

instance (Ord k) => MyFunctor (DataMap.Map k) where
  myfmap f x = DataMap.fromList $ 
                     DataList.map (\(p,q) ->(p,f q)) $ 
                     DataMap.toList x 
```

Enter fullscreen mode Exit fullscreen mode

### é€‚ç”¨å‡½å­

åœ¨è®¡ç®—æœºç§‘å­¦ä¸­ï¼Œapplicative æ˜¯å¯¹ä¸Šä¸‹æ–‡çš„æŠ½è±¡ï¼Œå®ƒèƒ½å¤Ÿå°†åŒä¸€ç±»å‹ä¸Šä¸‹æ–‡ä¸­çš„åŠŸèƒ½åº”ç”¨äºä¸Šä¸‹æ–‡ä¸­çš„æ‰€æœ‰å…ƒç´ ã€‚ä¾‹å¦‚ï¼Œå…·æœ‰åŒè´¨å…ƒç´ çš„åºåˆ— Aï¼Œä»¥åŠç”±å¯åº”ç”¨äºåºåˆ— A çš„å‡½æ•°ç»„æˆçš„åºåˆ— Bï¼Œè¿™äº§ç”Ÿäº†ç”±æ‰€æœ‰å‡½æ•°è½¬æ¢çš„å…ƒç´ çš„æ–°åºåˆ—ã€‚(è¶…çº§è¿·æƒ‘ï¼Ÿé—æ†¾çš„ğŸ˜•)

Haskell ä¸­é€‚ç”¨çš„ typeclass ä½äº Control ä¸­ã€‚é€‚ç”¨æ¨¡å—å¹¶å®šä¹‰äº†`pure`å’Œ`(<*>)`ã€‚

```
class (Functor f) => Applicative f where
    pure :: a -> f a
    (<*>) :: f (a -> b) -> f a -> f b 
```

Enter fullscreen mode Exit fullscreen mode

*   åº”ç”¨ç¨‹åºå¿…é¡»æ˜¯å‡½å­ã€‚è¿™æ˜¯ä¸€ä¸ªç±»çº¦æŸã€‚

*   æ¥å—ä»»ä½•ä¸Šä¸‹æ–‡ï¼Œå¹¶è¿”å›å…¶ä¸­ä¸Šä¸‹æ–‡çš„å€¼ã€‚

*   `(<*>)`æ˜¯`fmap`çš„è¡¨ç¤ºï¼Œå…¶ä¸­`<*>`å–ä¸€ä¸ªåŒ…å«å‡½æ•°çš„å‡½å­å’Œå¦ä¸€ä¸ªå‡½å­ï¼Œä»ç¬¬ä¸€ä¸ªå‡½å­è¿è¡Œè¯¥å‡½æ•°ï¼Œå¹¶å°†å…¶æ˜ å°„åˆ°ç¬¬äºŒä¸ªå‡½å­ä¸Šã€‚è€Œ`fmap`æ¥å—ä¸€ä¸ªå‡½æ•°å’Œä»¿å‡½æ•°ï¼Œå¹¶åœ¨ä»¿å‡½æ•°ä¸­åº”ç”¨è¯¥å‡½æ•°ã€‚

â€”

### åˆ—å‡ºä¸€ä¸ªé€‚ç”¨é¡¹ï¼

List è¿˜å®ä¾‹åŒ–äº†ä¸€ä¸ªå¯åº”ç”¨çš„ typeclassï¼Œå®ç°å¦‚ä¸‹:

```
instance Applicative [] where
    pure x = [x]
    fs <*> xs = [f x | f <- fs, x <- xs] 
```

Enter fullscreen mode Exit fullscreen mode

åœ¨è¿™é‡Œï¼Œ`(<*>)`çš„å®ç°åŸºæœ¬ä¸Šæ˜¯ä¸€ä¸ªåˆ—è¡¨ç†è§£ï¼Œå…¶ä¸­æ¯ä¸ªå‡½æ•°éƒ½åº”ç”¨äºæ¯ä¸ªå€¼ã€‚æ¯”å¦‚:

```
ghci> (*) <$> [2, 3] <*> [4, 5]
[8, 10, 12, 15] 
```

Enter fullscreen mode Exit fullscreen mode

å¦‚æœæ‚¨æƒ³å°†ç¬¬ä¸€ä¸ªåˆ—è¡¨ä¸­çš„æ¯ä¸ªå‡½æ•°åº”ç”¨åˆ°ç¬¬äºŒä¸ªåˆ—è¡¨ä¸­ç›¸åº”çš„å€¼ï¼ŒZipList typeclass éå¸¸æ–¹ä¾¿ã€‚

â€”

### å¥½å¥‡æ¡ˆä¾‹ä¹‹`Either`

ä¸¤è€…çš„åŸºæœ¬ Monad å®ä¾‹å®šä¹‰å¦‚ä¸‹ã€‚

```
instance Monad (Either e) where
  return = Right
  Left e  >>= _ = Left e
  Right a >>= f = f a 
```

Enter fullscreen mode Exit fullscreen mode

è¿™ä¸ªå®ä¾‹æœ‰å›ºæœ‰çš„`short-circuiting`ï¼Œæˆ‘ä»¬ä»å·¦åˆ°å³ï¼Œä¸€æ—¦ä¸€ä¸ªè®¡ç®—å¤±è´¥ï¼Œé‚£ä¹ˆæ‰€æœ‰çš„éƒ½å¤±è´¥ã€‚ä½†æ˜¯å¦‚æœä½ æƒ³æ”¶é›†åœ¨ä¸Šè¿°è®¡ç®—ä¸­ä»»ä½•åœ°æ–¹å‡ºç°çš„é”™è¯¯ä¿¡æ¯ï¼Œè¿™å°±è¿èƒŒäº†`(>>=)`å’Œ`lazy-evaluation/short-circuiting`ã€‚

æƒ°æ€§æ±‚å€¼æ˜¯å½“æˆ‘ä»¬ä»å·¦åˆ°å³è¿›è¡Œæ—¶ï¼Œå½“ä¸€ä¸ªè®¡ç®—â€œå¤±è´¥â€åˆ°å·¦è¾¹æ—¶ï¼Œé‚£ä¹ˆæ‰€æœ‰å…¶ä»–çš„ä¹Ÿä¸€æ ·ã€‚

è·å–ä¸€ä¸ªå‡½æ•°ï¼Œå°†å®ƒæ˜ å°„åˆ°ä¸€ä¸ªå•å­çš„å®ä¾‹ä¸Šï¼Œç„¶åå±•å¹³ç»“æœã€‚
T1ã€‘

`(>>=)`ä»`m a`äº§ç”Ÿ`m b`åªè¦å®ƒèƒ½è¿è¡Œ`(a -> m b)`ã€‚è¿™å°±è¦æ±‚ a çš„å€¼åœ¨è®¡ç®—æœŸé—´åº”è¯¥ç†æƒ³åœ°å­˜åœ¨ï¼Œè€Œè¿™ä¸¤è€…éƒ½æ˜¯ä¸å¯èƒ½çš„ã€‚

â€”

å› æ­¤ï¼Œè®©æˆ‘ä»¬é€šè¿‡å®šä¹‰ä»»ä¸€çš„**ä»¿å‡½æ•°å®ä¾‹æ¥å°è¯•è§£å†³ä¸Šè¿°é—®é¢˜ã€‚** 

```
instance Functor (Either a) where
    fmap f (Left x) = Left x
    fmap f (Right y) = Right (f y) 
```

Enter fullscreen mode Exit fullscreen mode

äº‹æƒ…æˆ‘ä»¬å¯ä»¥ä»ä¸Šé¢çš„å®šä¹‰ä¸­ç†è§£:

*   æˆ‘ä»¬çŸ¥é“`fmapÂ :: (c -> d) -> f c -> f d`çš„å®šä¹‰ã€‚

*   å¦‚æœæˆ‘ä»¬ç”¨ a ä»£æ›¿ fï¼Œæˆ‘ä»¬å¾—åˆ°
    `fmapÂ :: (c -> d) -> Either a c -> Either a d`

è¿™ç§å®ç°çš„é—®é¢˜æ˜¯æˆ‘ä»¬ä¸èƒ½æ˜ å°„åˆ°å·¦è¾¹ã€‚
(ğŸ˜±ä¸ºä»€ä¹ˆï¼Ÿ)ä¸ºäº†ç†è§£è¿™ä¸€ç‚¹ï¼Œè®©`Either a b`è®¡ç®—ï¼Œå®ƒå¯èƒ½æˆåŠŸå¹¶è¿”å› b æˆ–è€…å¤±è´¥å¹¶è¿”å›é”™è¯¯ aï¼Œç±»ä¼¼äº monad å®ä¾‹ã€‚å› æ­¤ï¼Œå‡½å­å®ä¾‹ä¸ä¼šæ˜ å°„å·¦ä¾§çš„å€¼ï¼Œå› ä¸ºæ‚¨å¯èƒ½å¸Œæœ›æ˜ å°„è®¡ç®—ï¼Œå¦‚æœå®ƒå¤±è´¥ï¼Œå°±æ²¡æœ‰ä»€ä¹ˆå¯æ“ä½œçš„ã€‚

â€”
è®©æˆ‘ä»¬çœ‹çœ‹æ˜¯å¦å¯ä»¥å®ç°ä¸€ä¸ª`Applicative instance`æ¥è§£å†³é—®é¢˜ï¼Œå®ƒä¸èƒ½æœ‰ç›¸åº”çš„å•å­ã€‚

æ­£å¦‚æˆ‘ä»¬çœ‹åˆ°çš„é€‚ç”¨çš„å®šä¹‰ï¼Œæˆ‘ä»¬å°†å®šä¹‰`pure`å’Œ`(<*>)`ã€‚

å®šä¹‰ pure ç›¸å½“ç®€å•ï¼Œå› ä¸ºæˆ‘ä»¬å¸Œæœ›å®ƒè¿”å›æ­£ç¡®çš„å…ƒç´ ã€‚`(<*>)`çš„å®ç°ç›¸å½“æ£˜æ‰‹ã€‚å®šä¹‰`(<*>)`
éœ€è¦è€ƒè™‘ä»¥ä¸‹æƒ…å†µ

```
instance Applicative (Either e) where
    pure                 =  Right
    Right f  <*> Right a  = Right (f a)    
    Left  e  <*> Right _ = Left e          
    Right _  <*> Left  e = Left e          
    Left e1  <*> Left e2 = Left (e1 <> e2) 
```

Enter fullscreen mode Exit fullscreen mode

*   ç¬¬ä¸€ä¸ªé™ˆè¿°æ˜¯çº¯ç²¹çš„é™ˆè¿°ã€‚

*   `(<*>)`å…è®¸å¹¶è¡Œè¯„ä¼°ï¼Œè€Œä¸ä¸€å®šéœ€è¦å…ˆå‰è®¡ç®—çš„ç»“æœæ¥è®¡ç®—å½“å‰å€¼ã€‚

*   å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æˆ‘ä»¬çš„çº¯åº”ç”¨ç¨‹åºæ¥æ”¶é›†é”™è¯¯ï¼Œå¦‚æœåºåˆ—ä¸­å­˜åœ¨ä»»ä½•å·¦ï¼Œåˆ™å¿½ç•¥å³ã€‚

*   ä¸€æ—¦é‡åˆ°å·¦è½¬å¼¯ï¼Œå®ƒå°±ä¸­æ­¢å¹¶è¿”å›å·¦è½¬å¼¯ã€‚

```
 ghci> (++) <$> Left "Hello" <*> undefined 
Left "Hello"                              -- not undefined

ghci> (++) <$> Right "Hello" <*> undefined 
*** Exception: Prelude.undefined          -- undefined

ghci> (++)  <$> Right "Hello" <*> Left " World"
Left " World"

ghci> (++)  <$> Right "Hello" <*> Right " World"
Right "Hello World" 
```

Enter fullscreen mode Exit fullscreen mode

â€”

### å±€é™æ€§

ä½¿ç”¨çº¯åº”ç”¨å‡½å­æœ‰ä¸€äº›é™åˆ¶ã€‚æ­£å¦‚æˆ‘ä»¬åœ¨`(>>=)Â :: m a -> (a -> m b) -> m b`çš„å®šä¹‰ä¸­çœ‹åˆ°çš„ï¼›è¿™æ„å‘³ç€æ²¡æœ‰`(>>=)`ä½ ä¸èƒ½é€‰æ‹©â€œåŸºäºä¹‹å‰å‘ç”Ÿçš„äº‹æƒ…æ¥ä¸‹æ¥åšä»€ä¹ˆâ€ã€‚
åŒæ ·ï¼Œå¦‚æœä½ å–ä¸€ä¸ªæ™®é€šçš„çº¯å‡½æ•°ï¼Œå¹¶ç»™å®ƒè¾“å…¥åº”ç”¨å‚æ•°ï¼Œæ¯”å¦‚

```
> f :: a -> b -> c 
> f <$> getLine <*> getProcessID "chrome" <*> getFreeMemory 
```

Enter fullscreen mode Exit fullscreen mode

æ— è®ºå¦‚ä½•ï¼Œæ‰€æœ‰çš„è®ºç‚¹éƒ½ä¼šè¢«è¯„ä¼°ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæ‚¨ä¸èƒ½è¡¨è¾¾ä¸ºâ€œå¦‚æœç¬¬äºŒä¸ªå‚æ•°å­˜åœ¨ï¼Œåˆ™ä¸­æ­¢å‰©ä½™çš„è®¡ç®—â€ã€‚å› æ­¤ï¼Œä»»ä½•é€’å½’çš„ä¸œè¥¿ï¼Œä»¥åŠå¤§å¤šæ•°äº¤äº’å¼ç¨‹åºéƒ½ä¸ä½¿ç”¨åº”ç”¨ç¨‹åºã€‚å¦ä¸€æ–¹é¢ï¼Œå•å­åœ¨è¿™ç§æƒ…å†µä¸‹æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„é€‰æ‹©ã€‚

åŸæ–‡-[Haskell ä¸­çš„é€‚ç”¨å‡½å­](https://medium.com/lazy-eval/applicative-functors-in-haskell-f509e1c764d3)

â€”
æ›´å¤šèµ„æº:

[http://learnyouahaskell . com/functors-applicative-functors-and-monoids](http://learnyouahaskell.com/functors-applicative-functors-and-monoids)
T3ã€‘http://adit . io/posts/2013-04-17-functorsï¼Œ_applicativesï¼Œ_ and _ monads _ in _ pictures . html
[https://hackage . haskell . org/package/base-4 . 8 . 1 . 0/docs/Control-applicative . html](https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Applicative.html)
T9