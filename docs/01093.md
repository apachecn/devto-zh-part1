# 软件安全性无可救药地被打破了

> 原文:[https://dev . to/bosepchuk/software-security-is-hopely-broken-lg1](https://dev.to/bosepchuk/software-security-is-hopelessly-broken-lg1)

作为软件开发人员，我们在保护我们从用户那里收集的数据方面做得很糟糕，因为软件安全性无可救药地被破坏了。这是一个很大的话题，所以我将把我的评论限制在编码、加密/哈希、web 服务器配置、监管以及我们可以为我们创建和维护的软件的安全性做些什么。

### 编程默认需要显著的安全性

我们在简单的事情上失败了。我们在代码库中硬编码 API 密码，然后发布在 github 上，不安全地存储用户密码，编写容易受到注入和溢出攻击的代码，在使用数据之前没有正确验证数据，没有保护我们的备份，没有删除我们不再需要的数据，等等。等等..

我在 2002 年左右买了一本关于安全编程的书，书中指出的所有风险今天仍然伴随着我们。在过去的 15 年里，我们几乎没有动过针！

我们要在软件安全问题上取得重大进展的唯一方法是让编程在默认情况下更安全。更努力的尝试并没有奏效，也不太可能在未来的绝大多数项目中奏效。

当然，如果每个开发人员都接受过安全培训，并且遵守程序员的誓言，那就太好了。这肯定会有帮助。如果你感兴趣的话，我写了一篇非常受欢迎的关于[软件专业性和安全性](https://smallbusinessprogramming.com/great-power-comes-great-responsibility/)的文章。

问题是，每次我们写一行代码时，我们已经有一千件事情要记住，如果认为人类(以我们可怜的 5 +/-2 的工作记忆)会记得一直做好每一件事，那就太天真了。(或者你的老板会让你在发布代码之前再花一个月的时间来检查你的代码是否存在安全问题。)

#### 用 C 安全编程基本上是不可能的

你有没有看过关于在 C 中正确范围检查数组索引的[安全指南？不好玩。谁会每次都 100%正确呢？如果你用 C 写一个重要的项目，你将很难保证你永远不会得到一个越界的数组索引，或者溢出，或者空指针，等等..](https://www.us-cert.gov/bsi/articles/knowledge/coding-practices/range-checking)

你可以将 MISRA C 标准的副本钉在开发人员的额头上，并对每一次提交进行 5 次检查，但你仍然会错过大量的错误。

#### 什么样子比较安全？

*   具有[自动边界检查](https://en.wikipedia.org/wiki/Bounds_checking)的计算机语言
*   自动转义输入以防止 SQL 注入攻击的数据库抽象层
*   默认情况下自动转义输出以防止跨站点脚本的模板引擎
*   表单生成器在每次提交时自动添加并检查唯一令牌，以防止跨站点请求伪造
*   使防止注入攻击变得容易的数据验证器
*   具有良好设计和测试的身份验证和授权功能的 web 框架
*   允许软件开发人员静态和动态检查他们的代码并报告优先问题列表的工具
*   易于使用的安全扫描仪

这些东西之所以有效，是因为您可以免费获得安全好处(但前提是您实际使用它们)。如果我们希望安全编码能够发挥作用，那么它必须是自动且免费的。

### 密码哈希和加密需要防白痴

我们需要简单的方法来获得最新编程实践的好处，而不需要成为专家。PHP 开发人员实际上已经在这方面做了一些令人印象深刻的工作。

#### 安全密码哈希

例如，PHP 中的[密码哈希](https://secure.php.net/manual/en/ref.password.php)现在使用起来很简单，默认情况下也很强大。PHP 的核心有三个函数，可以完成安全存储和验证密码所需的一切工作。我们在几个小时内升级了我们的一个网站。所以，PHP 现在负责我们密码的加盐和安全散列。将来有更好的东西出现时，我们的代码甚至会自动升级我们的散列。

这是最精彩的部分:使用 [PHP 的安全散列功能](https://paragonie.com/blog/2017/12/2018-guide-building-secure-php-software#secure-php-passwords)的人不需要理解安全最佳实践、salting、彩虹表或者 md5 和 sha-256 之间的区别。事情本该如此。

#### 安全应用层加密

应用级加密应该非常简单易用。任何人都应该能够调用 encrypt($cleartext，$key)和 decrypt($cyphertext，$key)，并且知道它是安全的，而不需要了解加密是如何工作的。

如果你是一个专家，继续使用较低层次的功能。但我们大多数人只需要加密一个字符串并安全地存储它，以便我们可以在以后解密它。所以只要给我们一些安全的东西，我们就会使用它。加密不像 PHP 中的密码散列那样容易使用，但它已经很接近了。查看这个实现(向下滚动查看示例代码)。我想象 simpleEncrypt()和 simpleDecrypt()或类似的东西最终会进入 PHP 核心。

### 默认情况下，服务器需要更易于配置和更安全

你曾经尝试过设置一个网络服务器并使其安全吗？我试过，而且在 Windows 或 Linux 上不好玩。做好这件事所需的知识水平是疯狂的。但是，即使您设法创建了您认为是“安全”的配置，您也不能保证您的服务器在明天或下周仍然安全。

什么会更好？想象一下，如果苹果为一个 web 服务器操作系统开发 GUI，而这个操作系统是按照 OpenBSD 项目的安全标准构建的。这超出了我的能力范围，所以如果我说了些傻话，请原谅。

#### 以下是我希望在安全的网络服务器操作系统中看到的一些特性:

*   很容易看到系统的配置以及它是如何随着时间的推移而改变的(以及谁改变了它)
*   服务器监控登录用户的行为，并报告任何可疑的行为(以及记录他们在会话期间所做和所见的一切)
*   很容易看出是否有人正在攻击您的系统，他们是如何攻击的，以及操作系统正在做什么来阻止攻击成功
*   如果服务器需要帮助来防御攻击，它应该联系管理员(并建议人类应该采取的行动)
*   操作系统应该只允许它认为安全的软件被执行(我知道这在实践中很有挑战性，但是我可以做梦)
*   配置更改是通过向导(或脚本)完成的，系统不允许你犯愚蠢的配置错误(比如用容易猜到的密码创建一个 ssh 帐户)
*   操作系统应该监控它的使用情况，并建议或自动关闭不需要的功能
*   操作系统应该自动安装签名的更新，而不需要重新启动，但如果必要的话允许回滚(或者有一个可配置的更新策略)
*   内置加密完整备份，一键恢复
*   操作系统应该警惕新硬件和插入其 USB 端口的任何东西
*   默认情况下，文件系统是加密的
*   默认情况下，操作系统使用地址空间布局随机化
*   可以从一个界面轻松管理多台服务器
*   服务器应该安全地失败(永远不要泄露关于它自己或它的数据的敏感信息)
*   操作系统应该能够运行自测，并告诉你所有可以访问/利用它的地方
*   操作系统应该从其他系统的成功和失败中学习，以提高其安全性和性能(就像今天的反病毒软件一样)
*   所有固件都经过加密签名

我知道这东西说起来容易做起来难，但你不能否认的事实是，这里有很大的改进空间。围绕让计算机更安全，也不乏争议。在许多方面，自由和灵活性与安全是不一致的。

### 新法规将迫使我们改变设计和构建软件的方式

我很想知道，当欧盟新的[数据保护法规](https://en.wikipedia.org/wiki/General_Data_Protection_Regulation)于 2018 年 5 月 25 日生效时，软件世界将会发生什么。这些[规定很具体，对不遵守规定的惩罚也很严厉](https://www.infoq.com/articles/gdpr-for-software-devs)，但是如何执行的细节还不清楚。如果 2%的包含用户数据的软件符合这些规定，我会感到惊讶。让你现有的软件兼容将会非常昂贵。

另外，这只是对非安全关键软件监管的开始。我预测，随着人们厌倦了数据泄露和我们蹩脚软件造成的损害，越来越多的监管将被抛向我们。人们会寻求政府保护。

我还想知道保险公司什么时候会根据他们开发的软件类型和开发的仔细程度来为企业设定常规保费。

看看这一切的结果应该会很有趣。

### 好了，软件安全无可救药的破了。接下来会发生什么？

我相信在接下来的几年里，我们在编写安全软件方面会稍有进步。但是坏人会继续轻而易举地窃取我们的数据。

我们将使用更安全的语言、更好的工具，以及逐渐改进的软件工程实践，来创建为我们的用户提供更多保护的软件(比如测试、静态分析和代码审查)。像谷歌、微软和脸书这样的大公司在编写安全软件方面会比小公司做得更好。应用程序和 IOT 设备仍将是一个绝对的灾区，但几乎所有的软件仍将容易受到攻击，因为，就像我之前说过的，软件安全性无可救药地被破坏了。

有太多的方法可以导致编程或配置错误，欺骗您战胜自己的安全性，或者从另一个层面(网络、路由器、操作系统、硬件、固件、物理等)攻击您的系统。).

此外，还有数十亿行代码永远也不可能升级到安全级别，因为:

*   这个软件已经被废弃了
*   修改现有软件的费用高得令人望而却步
*   基本上不可能给一个现有的不安全系统增加有效的安全控制
*   我们没有足够的安全专家
*   修理它没有钱

### 结论

事情是这样的:**我们的整个现代计算设备用胶带固定在一起**。在计算中没有一个基础层，我们可以下降到并说“在这个点以下的一切都是安全的，所以我们只是要从这个层面重建。”

不存在那样的东西。我们可以雇佣安全专家从头开始重新设计/重写一切(硬件、固件、操作系统、应用程序、协议等)。)疯狂地关注细节。但是**我们还不知道如何制造没有错误的复杂软件**，当然不是在我们这里谈论的规模上。

另外，你打算拿人民怎么办？他们也是系统的一部分。记住，坏人可以给你下药，用扳手打你，直到你说出所有的密码。

你还必须担心物理安全，因为有人可能会在你的键盘和电脑之间插入键盘记录器。或者从你的键盘上远程读取电动势([它也适用于有线键盘](http://www.zdnet.com/article/researchers-hack-wired-keyboards-hijack-keystrokes/))。或者在你的房间里靠近电脑的地方安装一个小摄像头，拍摄你的屏幕。或者激活你的网络摄像头，通过眼镜的反射来阅读你的屏幕。或者其他无数的事情。

没有。事实是，软件安全性无可救药地被破坏了。

### 能做什么？

*   **让您的软件保持最新** -安全更新是您拥有的最佳防御
*   遵守所有适用的法律法规，如[、GDPR](https://en.wikipedia.org/wiki/General_Data_Protection_Regulation) 、 [HIPPA](https://en.wikipedia.org/wiki/Health_Insurance_Portability_and_Accountability_Act) 、 [PCI-DSS](https://en.wikipedia.org/wiki/Payment_Card_Industry_Data_Security_Standard) 等。
*   自学安全最佳实践、工具和语言，以帮助您降低编写安全软件的成本
*   使用风险缓解策略首先保护您最敏感的数据，因为您无法一次解决所有问题
*   分配时间来修复优先级较低的安全问题，因为它们永远不会自己修复
*   通过与同事(包括程序员和非程序员)讨论安全问题来提高对这些问题的认识

你怎么看？你相信软件安全无可救药地被破坏了吗？我很想听听你的想法。