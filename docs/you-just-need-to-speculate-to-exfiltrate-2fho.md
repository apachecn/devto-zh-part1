# 你只需要推测就可以了

> 原文：<https://dev.to/__richardt/you-just-need-to-speculate-to-exfiltrate-2fho>

[![Meltdown & Spectre Bugs](img/7926ff2ca1619ef81c3d8c6915c552ab.png)T2】](https://res.cloudinary.com/practicaldev/image/fetch/s--Y4YKbUgt--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://approov.io/ext-images/Meltdown.png)

在上周的安全新闻发布后，有很多问题需要讨论。它被[崩溃和 Spectre](https://meltdownattack.com/) CPU 错误公告所主导——2018 年无疑有了一个有趣的开端。在这个分为两部分的博客的第一部分中，我将从更高的层次来看待这些错误。在第二部分中，我将聚焦于移动安全的含义，尤其是 Android。

虽然这些错误的补丁已经在工作中有一段时间了，但公告已经匆忙发布，有时会显示出来。然而 [The Register](https://www.theregister.co.uk/2018/01/04/intel_amd_arm_cpu_vulnerability/) 和 [Ars Technica](https://arstechnica.com/gadgets/2018/01/meltdown-and-spectre-heres-what-intel-apple-microsoft-others-are-doing-about-it/) 等已经提供了一些很好的报道，我在这里不再重复。

缓存侧通道攻击[并不是新的](https://www.usenix.org/node/184416)，但直到现在，这些攻击中的许多都有些做作。要使攻击起作用，需要有一个来自您试图窃听的受害者应用程序的强信号，而定位这一点对攻击者来说是最大的挑战。在这种情况下，强信号意味着高速缓存行访问模式本身揭示了一些秘密数据。换句话说，数据必须以特别方便的方式影响存储器访问模式。您试图窃取的一些关键数据需要用于计算地址，这些地址方便地跨越许多缓存线，以便为您提供一些有用的缓存侧通道信息，以便稍后进行监视。此外，您需要缓存布局在足够长的时间内保持完整，以便您的窃听代码可以观察到它。通常，受攻击代码执行的其他操作会很快降低缓存布局信息的质量。这些要求在现实中并不经常出现，所以尽管有一些侧信道通信的不错的演示，但在您想要攻击的代码中找到一个好的信号发生器的机会实际上相当小。

熔毁和幽灵从根本上改变了游戏。你可以制作你自己的信号生成代码，然后你可以窃听自己。非常方便。这更加通用，也更加强大。这里的关键见解是使用推测性执行来为您做到这一点。为了保持良好的性能，CPU 大部分时间都以推测方式执行。特别是，它们预测分支可能采取的方向，事实证明，它们有效地预测，当然，你肯定被允许访问你刚刚读取的那个内存位置。

首先让我们处理 Meltdown，它实际上只影响英特尔 CPU。从形式上来说，这是流氓数据缓存加载( [CVE-2017-5754](http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=2017-5754) )，这是对 CPU 无序推测性质的一种相当聪明的滥用。你要做的第一件事是从一个没有权限读取的内存位置加载。当你这样做的时候，你的代码会得到一个异常，它会停止，当然不会直接告诉你那个内存位置保存了什么。但是，事实证明，它并没有立即这样做，因为它将异常作为加载本身的一个单独的子操作来处理。因此，如果你巧妙地构造你的代码，你实际上可以加载数据，并将其转换成一个地址，然后从该位置加载。现在，当异常最终追上您时，您从原始加载中获得的所有寄存器状态都会回滚。就像从未发生过一样被冲走了。然而，您从该数据相关地址读取的事实仍然保留在缓存状态中。它没有被冲走。这种痕迹仍然存在，通过仔细测量代码中另一个线程的缓存状态，您可以推断出数据是什么。这是非常坏的消息。现在，你可以有效地读取任何你想读取的记忆，尽管这只是一点统计数据，而且非常间接。真正可怕的消息是，缺省情况下，Linux 和 Windows 使得机器的所有内存都可以在进程地址空间中访问。所以所有的秘密数据、密码和其他有用的信息都有可能被你的攻击代码获取。如果你能让你的代码在目标机器上运行，那么理论上你可以读取任何你想要的东西。CPU 安全隔离中一个相当严重的疏忽。这一点在之前并不明显，这确实很不寻常。投机性处决已经存在很多年了。一旦你意识到它的含义，这是导致集体叹息“当然，为什么以前没有人想到它”的那些见解之一。修复熔毁的补丁已经在工作中有一段时间了，并准备很快推出。从根本上来说，解决方法是确保 MMU 为一个进程映射的页面是它应该能够读取的页面，否则就不是很有趣。这被称为 Linux 的内核页表隔离( [KPTI](https://en.wikipedia.org/wiki/Kernel_page-table_isolation) )，Windows 也即将推出类似的修复。不过，这会对性能产生影响。有充分的理由让内核页面的其余部分可以快速访问。即使系统的性能会下降，我们也不会崩溃。因此，尽管最初的大部分歇斯底里是围绕 Meltdown 的影响，特别是在 AWS 等多租户云环境中，但补丁周期似乎应该很快赶上，Meltdown 可能会从头条新闻中消失。虽然主要的 Meltdown 错误不会影响 ARM CPUs，但他们定义了一个特殊的[变体 3a](https://developer.arm.com/support/security-update) ，借此某些系统寄存器内容可能会泄露给普通进程，但总体来说，这似乎没有英特尔变体严重。ARM 硬件上的 PoC 已经在[运行](https://github.com/lgeek/spec_poc_arm)。

我怀疑 Spectre 将会是一个不断给予的 bug。正如发现这一漏洞的研究人员所指出的那样，它肯定会在未来几年困扰我们。它的影响更深，也更难减轻。与 Meltdown 不同，Spectre 同样会影响 ARM 和 AMD 设备。这意味着手机和平板电脑也在 Spectre 相关数据泄露的范围之内。

Spectre 有两个变种。第一种被称为边界检查旁路( [CVE-2017-5753](http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=2017-5753) )。基本上，这需要一个相当特殊的代码序列，包括条件值的范围检查。它使用分支预测来执行不应该执行的代码块。想法是训练分支预测器执行一些条件代码，然后传入一个值，表示它不应该。然而，条件检查需要仔细地构造，以便它不能立即被评估。因此，CPU 不会等待和浪费时间，而是像上次一样继续执行条件代码。有什么坏处，对吧？没有比这更好的办法了。条件代码被构造为从攻击者控制的任意内存位置加载数据，然后将该数据用作再次从内存加载的地址。这里和 Meltdown 有明显的相似之处。第二次加载会在缓存布局中留下影响，即使在处理器赶上自己并意识到它根本不应该执行该代码路径之后。所以基本上你可以读取进程可以读取的任何内存。您还需要一个相对人为的代码序列来完成它，一个不太可能自然发生的序列，所以您真的需要能够自己生成代码。该 bug 允许您有效地从内存中加载进程可以以任何方式加载的内容。你可能会问这有什么大不了的。重要的是 JIT 和用户生成的代码，它们运行在流程的上下文中。内存绑定检查通常会确保这样的代码不能只读取任意内存，只能读取它的小沙箱中允许它读取的部分。这种 Spectre 变体允许从沙盒中逃脱。该公开展示了如何构建 Javascript，然后 JIT 生成利用该漏洞的确切序列。现在，在网页中运行的 Javascript 可能会访问所有的浏览器进程内存。这可能包括各种密码、凭证、cookies 和其他有用的机密信息，无论运行 advert 的恶意 Javascript 想窃取您的数据，都不应该访问这些信息。事实上，许多浏览器在一个单独的进程中运行每个标签，这似乎不太像我曾经认为的那样，是一种极端的行为。突然间，这看起来非常有先见之明。我昨天第一次发现的另一件事是，即使是 Linux 内核也有 JIT！显然有一种叫做 [eBPF](https://en.wikipedia.org/wiki/Berkeley_Packet_Filter) 的东西可以被利用来泄漏任意内核数据。不用说，所有这些东西的修复都在管道中，但它们更复杂，需要用特殊的栅栏指令生成不同的代码序列，以确保不良推测不会以这种方式泄露机密数据。所有这一切的更广泛、更长期的含义是，你不能相信你允许在你的过程的上下文中运行的用户代码，除非你真正考虑它。即使您用沙箱保护代码，限制它可以访问内容，这也不一定足够。突然间，我们不得不意识到程序生活在一个奇怪的类似量子的世界里，实际上可以采用它们从来不应该采用的代码路径。投机执行的抽象面纱已经被打破。

现在我们来看厉鬼分支靶向注射的第二种变体( [CVE-2017-5715](http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=2017-5715) )。这一个似乎是其中最奇怪的。这同样与分支预测有关，但这次是间接分支。间接分支发生得相当频繁，尤其是在允许多态方法覆盖的面向对象语言中。因此，加快它们的速度是非常重要的，否则它们会相当慢。这是因为 CPU 甚至不能开始填充它的管道，直到它知道下一条指令是什么，而现代 CPU 有相当长的管道要填充。事实证明，一个特定的间接分支上一次去了哪里，是它下一次去哪里的一个相当好的预测。因此，再一次，在没有更好的事情可做的情况下，一个典型的 CPU 会这样做，并推测性地执行到最后一个目标。为了支持这一点，CPU 中有一个称为分支目标缓冲区(BTB)的表，它记录了从指令地址到该指令可能到达的位置(如果是间接分支)的映射。因此，当决定对下一次进行预测时，这将得到更新。当然，这个表不可能无限大，条目之间会有一些冲突，但是最频繁执行的指令将被保留。它的作用就像最近的间接分支的高速缓存，在某些架构中被称为分支目标地址高速缓存(BTAC)。如果您的代码停止执行，然后传递到内核，然后可能传递到运行在同一个内核上的其他进程，那么 BTB 内容就会保留下来。保留这些条目是有意义的，因为当轮到您的代码再次执行时，一些有效的条目可能仍然存在。扔掉可能会加速执行的有用信息毫无意义，又有什么坏处呢？如果目标地址是错误的，那么 CPU 无论如何也没有更好的事情可做，错误的执行可以像从未发生过一样回滚，然后可以分支到正确的目的地。我相信你能看出这是怎么回事。正如我们已经知道的，投机性执行并不是没有副作用，事实证明，这些副作用可以被利用。

Spectre 分支目标注入的真正巧妙之处在于，攻击者可以选择推测性地执行什么代码。如果攻击者知道特定间接分支的地址，那么他们可以训练 BTB 指向他们想要的位置。那需要是已经在被攻击的进程中的代码，但是让我们假设攻击者知道该代码是什么和在哪里。代码不需要干净地执行，它只需要执行足够长的时间，以便将一些有用的东西泄漏到缓存状态中，供以后检查。此代码是推测性的，无论如何它都将是错误的预测，因此将被回滚。因此，基本上，如果攻击者想要知道间接分支调用站点上特定寄存器的值，他们需要找到一些代码，在地址计算和内存加载中使用该寄存器，从而在缓存状态中留下足够明显的痕迹。这与 ROP 小工具非常相似。这些是现有代码的短序列，如果攻击者可以在允许他们控制目标地址的进程中导致缓冲区溢出，但不能注入新代码，他们可以拼凑这些代码来做一些有用的事情。缓冲区溢出和 ROP 小工具链是应用程序安全的祸害。在幽灵事件中，我们拥有的是投机工具。我们可以在现有代码中选择正确的现有代码序列，这将给出我们想要的泄漏签名。与 ROP 小工具不同，我们不需要像缓冲区溢出这样的现有漏洞来利用它们。我们只需要更早地运行，并在 BTB 中设置我们的陷阱，以迫使另一个进程的代码不正确地推测，并在缓存中留下一些有用的状态，供我们稍后检查。当然，在实践中，这很难设置，并且似乎更容易泄漏小块信息(例如单个字节或字)而不是数据块，因为我们有害的 BTB 训练很快就被取消，并且我们通过缓存状态传输数据的能力有限。在我看来，这种攻击最明显的用途是软件按键记录。潜在地，在间接分支站点上运行的每个寄存器都容易被泄漏。我们只需要找到一个，例如，保存系统上最后一次按键的值。这当然可以是密码或机密消息的一部分。不太好。

请注意，为了利用这种 Spectre 变体，有必要了解您试图攻击的进程的确切代码布局。你需要知道这一点，这样你就可以为被颠覆的间接分支设置正确的 BTB 陷阱。由于地址空间布局随机化( [ASLR](https://en.wikipedia.org/wiki/Address_space_layout_randomization) )如今被广泛使用，作为对 ROP 小工具攻击的防御，这不一定是简单明了的。有各种各样的技术来尝试和推断代码地址，但这确实在已经错综复杂的因果链中增加了另一层复杂性，这是使这种攻击实际起作用所必需的。

对这一缺陷的修复也在进行中。特别地，该方法依赖于存在于上下文切换边界之外的 BTB 训练。英特尔有一个[微码更新](https://lwn.net/Articles/743019/)即将到来，它将禁止跨边界保留条目，有效地使这个 bug 不可利用。ARM 提供了类似的补丁，可以禁用或清除跨上下文切换边界的 BTB。在这个阶段，还不清楚这会对性能产生什么影响。肯定会有的。出于良好的性能原因，传统上会保留 BTB 内容。编译器补丁也以新的“ [retpoline](https://support.google.com/faqs/answer/7625886) ”特性的形式出现。这允许重新编译应用程序，使其不再易受影响，或者实际上内核可以在启用此功能的情况下重新编译。这尤其适用于应用程序可能在未打补丁的环境中运行的情况。Retpolines 看起来很丑，但是可以解决这个问题。它们基本上导致编译器用更复杂、更慢的序列替换间接分支和调用，滥用返回指令来做同样的事情。这要慢得多，但不受 Spectre 的影响，因为回报不使用 BTB 进行预测。目前还不清楚类似的 Retpoline 修复是否会在其他编译和 JIT 语言中出现，如 Java、C#、Python 或 Go。

在第二部分中，我将讨论这一切对移动安全意味着什么。这些错误绝对不仅限于英特尔设备。